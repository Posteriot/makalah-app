# Blog CMS Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add full admin CMS for blog posts with WordPress-like TipTap editor supporting inline images and cover image upload.

**Architecture:** Blog already has data-driven frontend (`blogSections` table) and public queries. We add: (1) `content` field for TipTap JSON body, (2) `coverImageId` for Convex storage cover images, (3) admin CRUD mutations, (4) full blog post editor with TipTap + Image extension, (5) wire into existing ContentManager. Public queries resolve cover image URLs server-side for efficiency.

**Tech Stack:** Convex, TipTap (StarterKit + Link + Image), React, Iconoir, existing CmsImageUpload component

---

## Context

### Current State
- `blogSections` table exists with `blocks: v.array(documentationBlock)` and `coverImage: v.optional(v.string())`
- Public queries exist: `getPublishedPosts`, `getPostBySlug`, `getFeaturedPost`
- Blog frontend fully data-driven from Convex (BlogLandingPage, BlogArticlePage, BlogHeadlineSection, BlogFeedSection)
- NO admin CRUD mutations (only `seedBlogPosts` + `clearBlogPosts`)
- NO admin editor UI
- Blog NOT in ContentManager sidebar

### Key Decisions
1. **Single TipTap editor** (not structured blocks) — WordPress-like experience where admin writes continuously and inserts images inline
2. **`content: v.optional(v.string())`** field at post level for TipTap JSON — `blocks` kept for backward compatibility with seed data
3. **`coverImageId: v.optional(v.id("_storage"))`** replaces `coverImage: v.optional(v.string())` — Convex file storage for cover/thumbnail images
4. **Server-side URL resolution** — public queries resolve `coverImageId` → `coverImageUrl` so frontend gets ready-to-use URLs
5. **RichTextRenderer** gets Image extension for rendering inline images in articles

### Existing Patterns to Follow
- `DocSectionListEditor` / `DocSectionEditor` pattern for list + editor navigation
- `SectionBlockEditor` for TipTap + inline image upload via Convex storage
- `CmsImageUpload` component for cover image upload
- `documentationSections.ts` for admin CRUD mutation patterns (requireRole, upsertSection)
- ContentManager doc slug state pattern for blog slug state

---

## Task 1: Schema — Add content field + change coverImage to storage ID

**Files:**
- Modify: `convex/schema.ts` (blogSections table, ~lines 642-660)

**What to do:**

In `blogSections` table definition:
1. Add `content: v.optional(v.string())` — TipTap JSON string for article body
2. Replace `coverImage: v.optional(v.string())` with `coverImageId: v.optional(v.id("_storage"))`

```typescript
blogSections: defineTable({
  slug: v.string(),
  title: v.string(),
  excerpt: v.string(),
  author: v.string(),
  category: v.string(),
  readTime: v.string(),
  featured: v.boolean(),
  isPublished: v.boolean(),
  publishedAt: v.number(),
  content: v.optional(v.string()),          // NEW: TipTap JSON body
  blocks: v.array(documentationBlock),       // kept for backward compat
  coverImageId: v.optional(v.id("_storage")), // CHANGED: was coverImage string
  createdAt: v.number(),
  updatedAt: v.number(),
})
```

**Commit:** `feat(blog-cms): add content field + coverImageId to schema`

---

## Task 2: Admin CRUD mutations in blog.ts

**Files:**
- Modify: `convex/blog.ts`

**What to do:**

Add imports and admin mutations alongside existing public queries. Keep existing `seedBlogPosts` and `clearBlogPosts`.

Add these functions:

### Admin queries:

```typescript
import { requireRole } from "./permissions"

export const listAllPosts = query({
  args: { requestorId: v.id("users") },
  handler: async (ctx, args) => {
    await requireRole(ctx.db, args.requestorId, "admin")
    const posts = await ctx.db
      .query("blogSections")
      .order("desc")
      .collect()
    return posts
  },
})

export const getPostBySlugAdmin = query({
  args: { requestorId: v.id("users"), slug: v.string() },
  handler: async (ctx, args) => {
    await requireRole(ctx.db, args.requestorId, "admin")
    return await ctx.db
      .query("blogSections")
      .withIndex("by_slug", (q) => q.eq("slug", args.slug))
      .first()
  },
})
```

### Admin mutations:

```typescript
export const upsertPost = mutation({
  args: {
    requestorId: v.id("users"),
    id: v.optional(v.id("blogSections")),
    slug: v.string(),
    title: v.string(),
    excerpt: v.string(),
    author: v.string(),
    category: v.string(),
    readTime: v.string(),
    featured: v.boolean(),
    isPublished: v.boolean(),
    publishedAt: v.number(),
    content: v.optional(v.string()),
    coverImageId: v.optional(v.id("_storage")),
  },
  handler: async (ctx, args) => {
    await requireRole(ctx.db, args.requestorId, "admin")
    const { requestorId, id, ...data } = args
    const now = Date.now()

    if (id) {
      await ctx.db.patch(id, { ...data, updatedAt: now })
      return id
    }
    return await ctx.db.insert("blogSections", {
      ...data,
      blocks: [],
      createdAt: now,
      updatedAt: now,
    })
  },
})

export const deletePost = mutation({
  args: { requestorId: v.id("users"), id: v.id("blogSections") },
  handler: async (ctx, args) => {
    await requireRole(ctx.db, args.requestorId, "admin")
    const post = await ctx.db.get(args.id)
    if (!post) throw new Error("Blog post not found")
    await ctx.db.delete(args.id)
  },
})

export const generateBlogUploadUrl = mutation({
  args: { requestorId: v.id("users") },
  handler: async (ctx, args) => {
    await requireRole(ctx.db, args.requestorId, "admin")
    return await ctx.storage.generateUploadUrl()
  },
})

export const getBlogImageUrl = query({
  args: { storageId: v.id("_storage") },
  handler: async (ctx, args) => {
    return await ctx.storage.getUrl(args.storageId)
  },
})

export const getBlogImageUrlMutation = mutation({
  args: { storageId: v.id("_storage") },
  handler: async (ctx, args) => {
    return await ctx.storage.getUrl(args.storageId)
  },
})
```

### Update existing public queries for coverImageUrl resolution:

Modify `getPublishedPosts`, `getPostBySlug`, `getFeaturedPost` to resolve `coverImageId` → `coverImageUrl`:

```typescript
// Helper used by all 3 queries
async function resolvePostCoverUrl(
  ctx: { storage: { getUrl: (id: Id<"_storage">) => Promise<string | null> } },
  post: Doc<"blogSections">
) {
  return {
    ...post,
    coverImageUrl: post.coverImageId
      ? await ctx.storage.getUrl(post.coverImageId)
      : null,
  }
}

// In getPublishedPosts handler, after collecting:
return Promise.all(posts.map((p) => resolvePostCoverUrl(ctx, p)))

// In getPostBySlug handler:
const post = await ctx.db.query(...).first()
if (!post) return null
return resolvePostCoverUrl(ctx, post)

// In getFeaturedPost handler:
const post = await ctx.db.query(...).first()
if (!post) return null
return resolvePostCoverUrl(ctx, post)
```

Also update `seedBlogPosts` to remove `coverImage` field references (they use `undefined` anyway, but remove the field entirely since schema changed).

**Commit:** `feat(blog-cms): add admin CRUD mutations + coverImageUrl resolution`

---

## Task 3: Update blog frontend types + components for coverImageUrl

**Files:**
- Modify: `src/components/marketing/blog/types.ts`
- Modify: `src/components/marketing/blog/BlogHeadlineSection.tsx`
- Modify: `src/components/marketing/blog/BlogFeedSection.tsx`
- Modify: `src/components/marketing/blog/BlogArticlePage.tsx`

**What to do:**

### types.ts

The query return type now includes `coverImageUrl`. Update `BlogPost`:

```typescript
import type { Doc } from "@convex/_generated/dataModel"

export type BlogPost = Doc<"blogSections"> & { coverImageUrl?: string | null }
```

### BlogHeadlineSection.tsx

Replace `headlinePost.coverImage` with `headlinePost.coverImageUrl`:

```typescript
// Line ~40-46: change coverImage references
const headlineThumbSrc = headlinePost.coverImageUrl
  ?? createPlaceholderImageDataUri({ ... })

// Line ~66: unoptimized check
unoptimized={!headlinePost.coverImageUrl}
```

### BlogFeedSection.tsx

In `RowThumbnail` component: change `coverImage?: string` prop to `coverImageUrl`:

```typescript
function RowThumbnail({
  title,
  coverImageUrl,
  category,
}: {
  title: string
  coverImageUrl?: string | null
  category: string
}) {
  // ...
  if (coverImageUrl) {
    return <Image src={coverImageUrl} ... />
  }
  // fallback to placeholder
}
```

Update all call sites passing the prop.

### BlogArticlePage.tsx

1. Change `post.coverImage` → `post.coverImageUrl` in the cover image rendering (~lines 199-208, 311-319)
2. Add RichTextRenderer for `content` field — if `post.content` exists, render via RichTextRenderer instead of blocks:

```tsx
// Import at top:
import { RichTextRenderer } from "@/components/marketing/RichTextRenderer"

// In the article section (~line 372-391):
<article className="md:col-span-12">
  <div className={cn("rounded-shell bg-card/90 p-6 dark:bg-slate-800/90 md:p-8", "space-y-8")}>
    {post.content ? (
      <RichTextRenderer content={post.content} />
    ) : blocks.length > 0 ? (
      blocks.map((block, index) => (
        <BlockRenderer key={`${block.type}-${index}`} block={block} />
      ))
    ) : (
      <section>
        <h2>Ringkasan</h2>
        <p>{post.excerpt}</p>
      </section>
    )}
  </div>
</article>
```

**Commit:** `feat(blog-cms): update frontend for coverImageUrl + TipTap content rendering`

---

## Task 4: Add Image extension to RichTextRenderer

**Files:**
- Modify: `src/components/marketing/RichTextRenderer.tsx`

**What to do:**

RichTextRenderer currently only has StarterKit + Link. Add Image extension so inline images in blog TipTap content render properly:

```typescript
import Image from "@tiptap/extension-image"

// In useEditor extensions array, add:
Image.configure({
  HTMLAttributes: {
    class: "rounded-action my-4 max-w-full",
  },
}),
```

Also add image CSS to the className string:
```
[&_.ProseMirror_img]:rounded-action [&_.ProseMirror_img]:my-4 [&_.ProseMirror_img]:max-w-full
```

**Commit:** `feat(blog-cms): add Image extension to RichTextRenderer`

---

## Task 5: Create BlogPostListEditor component

**Files:**
- Create: `src/components/admin/cms/BlogPostListEditor.tsx`

**What to do:**

Follow the pattern of `DocSectionListEditor.tsx`. Build a list of all blog posts with:
- Post title, category badge, published status dot (green = published, gray = draft)
- Featured badge (amber) if `featured === true`
- Published date (formatted)
- Edit button → calls `onSelectPost(slug)`
- "Buat Post Baru" button → calls `onCreateNew()`
- Delete button with confirmation

Query: `api.blog.listAllPosts` with `{ requestorId: userId }`

Sort: by `publishedAt` desc (newest first).

Category badge colors: match the existing normalizeCategory system (Update=emerald, Tutorial=blue, Opini=amber, Event=fuchsia).

**Commit:** `feat(blog-cms): create BlogPostListEditor`

---

## Task 6: Create BlogPostEditor component

**Files:**
- Create: `src/components/admin/cms/BlogPostEditor.tsx`

**What to do:**

Full blog post editor. Follow `DocSectionEditor.tsx` pattern but simpler (no blocks management).

### Props:
```typescript
type Props = {
  slug: string | null  // null = create new
  userId: Id<"users">
  onBack: () => void
}
```

### Layout:
1. **Back button** (NavArrowLeft) + title "Edit Post" / "Post Baru"
2. **Metadata section:**
   - Title (text input)
   - Slug (text input, auto-generated from title on create, editable)
   - Excerpt (textarea, 2-3 lines)
   - Author (text input)
   - Category (select: Update, Tutorial, Opini, Event)
   - Read time (text input, e.g. "8 menit")
   - Published date (date input, stored as timestamp)
   - Featured toggle (Switch)
   - Published toggle (Switch)
3. **Cover Image** — reuse `CmsImageUpload` component with `aspectRatio="16/9"`
   - Uses `api.blog.generateBlogUploadUrl` for upload
   - Uses `api.blog.getBlogImageUrl` for preview
   - NOTE: CmsImageUpload currently uses `api.pageContent.generateUploadUrl`. For blog, we need to either (a) make CmsImageUpload accept custom mutation/query props, or (b) create a thin wrapper. Approach (a) is cleaner:
   - Add optional props to CmsImageUpload: `generateUploadUrlFn` and `getImageUrlQuery` with defaults to pageContent versions
4. **Article body** — Full TipTap editor with toolbar (same as SectionBlockEditor):
   - Bold, Italic, Headings, Lists, Blockquote, Link, Image upload
   - Image upload: uses `api.blog.generateBlogUploadUrl` → upload file → `api.blog.getBlogImageUrlMutation` → insert into editor
   - `immediatelyRender: false` for SSR safety
5. **Save button** — calls `api.blog.upsertPost`

### Data flow:
- Fetch existing: `useQuery(api.blog.getPostBySlugAdmin, { requestorId, slug })` when slug !== null
- Initialize form state from query data
- On save: call `upsertPost` mutation

### Slug auto-generation:
```typescript
function generateSlug(title: string): string {
  return title
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, "")
    .replace(/\s+/g, "-")
    .replace(/-+/g, "-")
    .slice(0, 80)
}
```

**Commit:** `feat(blog-cms): create BlogPostEditor with TipTap + cover image`

---

## Task 7: Make CmsImageUpload accept custom upload/query functions

**Files:**
- Modify: `src/components/admin/cms/CmsImageUpload.tsx`

**What to do:**

Currently CmsImageUpload hardcodes `api.pageContent.generateUploadUrl` and `api.pageContent.getImageUrl`. Make these configurable with defaults:

```typescript
type CmsImageUploadProps = {
  currentImageId?: Id<"_storage"> | null
  onUpload: (storageId: Id<"_storage">) => void
  userId: Id<"users">
  label?: string
  aspectRatio?: string
  // NEW: optional custom functions
  generateUploadUrl?: typeof api.pageContent.generateUploadUrl
  getImageUrl?: typeof api.pageContent.getImageUrl
}
```

Default values:
```typescript
generateUploadUrl = api.pageContent.generateUploadUrl,
getImageUrl = api.pageContent.getImageUrl,
```

Then BlogPostEditor passes:
```typescript
<CmsImageUpload
  generateUploadUrl={api.blog.generateBlogUploadUrl}
  getImageUrl={api.blog.getBlogImageUrl}
  ...
/>
```

NOTE: The function references (`api.blog.*`) are Convex FunctionReference types. The prop types should use the generic Convex types. Check if `typeof api.pageContent.generateUploadUrl` works. If TypeScript complains, use a simpler approach: accept `generateUploadUrlFn` as `"pageContent" | "blog"` string and switch internally. Use whichever approach compiles cleanly.

**Commit:** `feat(blog-cms): make CmsImageUpload accept custom upload functions`

---

## Task 8: Wire blog into ContentManager

**Files:**
- Modify: `src/components/admin/ContentManager.tsx`

**What to do:**

Follow the exact pattern used for documentation:

1. Add imports:
```typescript
import { BlogPostListEditor } from "./cms/BlogPostListEditor"
import { BlogPostEditor } from "./cms/BlogPostEditor"
```

2. Add `"blog"` to `PageId` type:
```typescript
type PageId = "home" | "about" | "privacy" | "security" | "terms" | "header" | "footer" | "documentation" | "blog"
```

3. Add to `PAGES_NAV.pages` array (after documentation):
```typescript
{ id: "blog", label: "Blog" },
```

4. Add `selectedBlogSlug` state:
```typescript
const [selectedBlogSlug, setSelectedBlogSlug] = useState<string | null>(null)
```

5. Reset `selectedBlogSlug` on page change (in `handlePageClick` for non-section pages):
```typescript
setSelectedBlogSlug(null)
```

6. Add routing in the editor panel conditional chain (before the fallback):
```tsx
) : selectedPage === "blog" && selectedBlogSlug === null ? (
  <BlogPostListEditor
    userId={userId}
    onSelectPost={(slug) => setSelectedBlogSlug(slug)}
    onCreateNew={() => setSelectedBlogSlug("__new__")}
  />
) : selectedPage === "blog" && selectedBlogSlug !== null ? (
  <BlogPostEditor
    slug={selectedBlogSlug === "__new__" ? null : selectedBlogSlug}
    userId={userId}
    onBack={() => setSelectedBlogSlug(null)}
  />
```

**Commit:** `feat(blog-cms): wire blog into ContentManager`

---

## Task 9: Lint + test verification

**Files:** None (verification only)

**What to do:**

1. Run `npm run lint` — fix any new errors introduced by blog CMS tasks
2. Run `npm run test` — verify no regressions (expect same 7/8 pass, 64/68 tests baseline)
3. Verify no TypeScript errors in blog-related files

**Commit:** Fix any lint issues found

---

## Execution Order

Tasks can be partially parallelized:

```
Task 1 (schema) ──────────────────────────┐
Task 7 (CmsImageUpload flexibility) ──────┤
                                          ├── Task 2 (mutations) ─── Task 3 (frontend updates)
Task 4 (RichTextRenderer Image) ──────────┤
                                          ├── Task 5 (BlogPostListEditor)
                                          ├── Task 6 (BlogPostEditor)
                                          └── Task 8 (ContentManager wiring)
                                               └── Task 9 (lint/test)
```

- **Parallel group 1:** Tasks 1, 4, 7 (independent schema/component changes)
- **Sequential:** Task 2 depends on Task 1 (schema)
- **Parallel group 2:** Tasks 3, 5, 6 depend on Task 2 (mutations exist)
- **Sequential:** Task 8 depends on Tasks 5+6 (components exist)
- **Final:** Task 9 (verification)
